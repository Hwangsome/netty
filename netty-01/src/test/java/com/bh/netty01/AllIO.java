package com.bh.netty01;

/**
 * <h2>传统阻塞I/O服务模型</h2>
 * <img width="640" height="320" src="../../../../../../../README.assets/image-20221102141416271.png">
 *  <h3>问题分析</h3>
 *  <ol>
 *      <li>当并发数很大，就会创建大量的线程，占用很大的系统资源</li>
 *      <li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作，造成线程资源浪费</li>
 *  </ol>
 *
 *  <h2>Reactor模式</h2>
 *  <p>复用结合线程池，就是Reactor 模式基本思想的设计</p>
 *  <img width="640" height="320" src="../../../../../../../README.assets/image-20221102141813746.png">
 *  <h3>针对传统阻塞IO服务模型的2个缺点的解决方案</h3>
 *  <ol>
 *      <li>基于io复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有的连接。当某个连接有新的数据可以处理的时候，
 *      操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理， Reactor对应的叫法：1⃣️ 反应器模式 2⃣️ 分发者模式 3⃣️ 通知者模式
 *      </li>
 *      <li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</li>
 *  </ol>
 *
 *  <h2>Reactor 模式中的核心组成</h2>
 *  <ol>
 *      <li>Reactor :Reactor在一个单独的线程中运行，负责监听 和 分发事件， 分发给适当的处理程序来对IO事件做出反应。</li>
 *      <li>Handlers:处理程序执行IO事件要完成的实际事件，Reactor通过调度适当的处理程序来响应IO事件，处理程序执行非阻塞的操作</li>
 *  </ol>
 *
 *  <h2>Reactor 模式中的的分类</h2>
 *  <ol>
 *      <li>单Reactor单线程</li>
 *      <li>单Reactor多线程</li>
 *      <li>主从Reactor多线程</li>
 *  </ol>
 *  <h3>单Reactor单线程</h3>
 *
 *
 * <h2>Reactor 模式具有由下的优点</h2>
 * <ol>
 *     <li>响应块，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的</li>
 *     <li>可以最大成都的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
 *     <li>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>
 *     <li>复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
 * </ol>
 *
 * <h2>Netty模型</h2>
 */
public class AllIO {
}
