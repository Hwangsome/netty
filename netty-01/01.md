# NIO
channel:

selector:
解决问题：监控客户端的channel,监控当客户给selector发送请求的时候是否可以建立正常的通信。
正常通信：1. 正常建立联系。 2. channel 中没有阻塞。
当selector监控的channel可以正常网络通信的时候，在分配线程为客户端提供服务。
当监控到chanel阻塞的时候，将分配给客户端的线程再回收回去。再将这个线程分配给其他客户端使用。
这就是NIO于传统IO的区别，一个线程可以被多个客户端使用，即使客户端阻塞。


## Buffer
所有流的数据存储到buffer中，但是我们不知道buffer的数据是往外写还是往里存
区分：
写模式：1. 新创建 2. clear() 。写是程序外面往buffer写。 目的是获得外部的数据（文件，网络的数据）
读模式：1. flip() 。 读是程序去读取buffer。程序读取buffer中的数据，为了在程序中使用


ByteBuffer 被设计为抽象类
啥时候时候使用接口，啥时候使用抽象类
1。 抽象的概念（名词）设计成抽象类，比如动物，形状，汽车。。。
2。 抽象的动作功能 （动词） 设计成接口 dao,service。。。

内存泄露：
100m内存，但是实际处理的数据为80m，内存就不够了
原因：1。 没有主动析构，主动释放内存 2。 内存碎片
内存溢出：
100m内存，实际的操作过程，真实数据120m，一次性读取到内存，内存溢出

日常使用ByteBuffer中，需要掌握
1。 何时使用读模式
2。 何时使用写模式